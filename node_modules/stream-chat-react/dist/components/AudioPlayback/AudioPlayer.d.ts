/// <reference types="lodash" />
import { StateStore } from 'stream-chat';
import type { AudioPlayerPlugin } from './plugins';
import type { AudioPlayerPool } from './AudioPlayerPool';
export type AudioPlayerErrorCode = 'failed-to-start' | 'not-playable' | 'seek-not-supported' | (string & {});
export type RegisterAudioPlayerErrorParams = {
    error?: Error;
    errCode?: AudioPlayerErrorCode;
};
export type AudioPlayerDescriptor = {
    id: string;
    src: string;
    /** Audio duration in seconds. */
    durationSeconds?: number;
    fileSize?: number | string;
    mimeType?: string;
    title?: string;
    waveformData?: number[];
};
export type AudioPlayerPlayAudioParams = {
    currentPlaybackRate?: number;
    playbackRates?: number[];
};
export type AudioPlayerState = {
    /** Signals whether the browser can play the record. */
    canPlayRecord: boolean;
    /** Current playback speed. Initiated with the first item of the playbackRates array. */
    currentPlaybackRate: number;
    /** The audio element ref */
    elementRef: HTMLAudioElement | null;
    /** Signals whether the playback is in progress. */
    isPlaying: boolean;
    /** Keeps the latest playback error reference. */
    playbackError: Error | null;
    /** An array of fractional numeric values of playback speed to override the defaults (1.0, 1.5, 2.0) */
    playbackRates: number[];
    /** Playback progress expressed in percent. */
    progressPercent: number;
    /** Playback progress expressed in seconds. */
    secondsElapsed: number;
};
export type AudioPlayerOptions = AudioPlayerDescriptor & {
    /** An array of fractional numeric values of playback speed to override the defaults (1.0, 1.5, 2.0) */
    playbackRates?: number[];
    plugins?: AudioPlayerPlugin[];
    pool: AudioPlayerPool;
};
export declare const defaultRegisterAudioPlayerError: ({ error, }?: RegisterAudioPlayerErrorParams) => void;
export declare const elementIsPlaying: (audioElement: HTMLAudioElement | null) => boolean | null;
export type SeekFn = (params: {
    clientX: number;
    currentTarget: HTMLDivElement;
}) => Promise<void>;
export declare class AudioPlayer {
    state: StateStore<AudioPlayerState>;
    /** The audio MIME type that is checked before the audio is played. If the type is not supported the controller registers error in playbackError. */
    private _data;
    private _plugins;
    private playTimeout;
    private unsubscribeEventListeners;
    private _pool;
    private _disposed;
    private _pendingLoadedMeta?;
    private _elementIsReadyPromise?;
    private _restoringPosition;
    private _removalTimeout;
    constructor({ durationSeconds, fileSize, id, mimeType, playbackRates: customPlaybackRates, plugins, pool, src, title, waveformData, }: AudioPlayerOptions);
    private get plugins();
    get canPlayRecord(): boolean;
    get elementRef(): HTMLAudioElement | null;
    get isPlaying(): boolean;
    get currentPlaybackRate(): number;
    get playbackRates(): number[];
    get durationSeconds(): number | undefined;
    get fileSize(): string | number | undefined;
    get id(): string;
    get src(): string;
    get mimeType(): string | undefined;
    get title(): string | undefined;
    get waveformData(): number[] | undefined;
    get secondsElapsed(): number;
    get progressPercent(): number;
    get disposed(): boolean;
    private ensureElementRef;
    private setPlaybackStartSafetyTimeout;
    private clearPlaybackStartSafetyTimeout;
    private clearPendingLoadedMeta;
    private restoreSavedPosition;
    setDescriptor(descriptor: AudioPlayerDescriptor): void;
    private releaseElement;
    private elementIsReady;
    private setRef;
    setSecondsElapsed: (secondsElapsed: number) => void;
    setPlugins(setter: (currentPlugins: AudioPlayerPlugin[]) => AudioPlayerPlugin[]): void;
    canPlayMimeType: (mimeType: string) => boolean;
    play: (params?: AudioPlayerPlayAudioParams) => Promise<void>;
    pause: () => void;
    stop: () => void;
    togglePlay: () => Promise<void>;
    increasePlaybackRate: () => void;
    seek: import("lodash").DebouncedFunc<SeekFn>;
    registerError: (params: RegisterAudioPlayerErrorParams) => void;
    /**
     * Removes the audio element reference, event listeners and audio player from the player pool.
     * Helpful when only a single AudioPlayer instance is to be removed from the AudioPlayerPool.
     */
    requestRemoval: () => void;
    cancelScheduledRemoval: () => void;
    scheduleRemoval: (ms?: number) => void;
    /**
     * Releases only the underlying element back to the pool without disposing the player instance.
     * Used by the pool to hand off the shared element in single-playback mode.
     */
    releaseElementForHandoff: () => void;
    registerSubscriptions: () => void;
}
