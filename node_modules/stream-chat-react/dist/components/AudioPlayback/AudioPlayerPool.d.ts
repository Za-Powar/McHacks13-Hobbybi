import { AudioPlayer, type AudioPlayerOptions } from './AudioPlayer';
import { StateStore } from 'stream-chat';
export type AudioPlayerPoolState = {
    activeAudioPlayer: AudioPlayer | null;
};
export declare class AudioPlayerPool {
    state: StateStore<AudioPlayerPoolState>;
    private pool;
    private audios;
    private sharedAudio;
    private sharedOwnerId;
    private readonly allowConcurrentPlayback;
    constructor(config?: {
        allowConcurrentPlayback?: boolean;
    });
    get players(): AudioPlayer[];
    get activeAudioPlayer(): AudioPlayer | null;
    getOrAdd: (params: Omit<AudioPlayerOptions, 'pool'>) => AudioPlayer;
    /**
     * In case of allowConcurrentPlayback enabled, a new Audio is created and assigned to the given audioPlayer owner.
     * In case of disabled concurrency, the shared audio ownership is transferred to the new owner loading the owner's
     * source.
     *
     * @param ownerId
     * @param src
     */
    acquireElement: ({ ownerId, src }: {
        ownerId: string;
        src: string;
    }) => HTMLAudioElement;
    /**
     * Removes the given audio players ownership of the shared audio element (in case of concurrent playback is disabled)
     * and pauses the reproduction of the audio.
     * In case of concurrent playback mode (allowConcurrentPlayback enabled), the audio is paused,
     * its source cleared and removed from the audios pool readied for garbage collection.
     *
     * @param ownerId
     */
    releaseElement: (ownerId: string) => void;
    /** Sets active audio player when allowConcurrentPlayback is disabled */
    setActiveAudioPlayer: (activeAudioPlayer: AudioPlayer | null) => void;
    /** Removes the AudioPlayer instance from the pool of players */
    deregister(id: string): void;
    /** Performs all the necessary cleanup actions and removes the player from the pool */
    remove: (id: string) => void;
    /** Removes and cleans up all the players from the pool */
    clear: () => void;
    registerSubscriptions: () => void;
}
